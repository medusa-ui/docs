"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[702],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return p}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),h=c(n),p=r,f=h["".concat(l,".").concat(p)]||h[p]||u[p]||i;return n?a.createElement(f,o(o({ref:t},d),{},{components:n})):a.createElement(f,o({ref:t},d))}));function p(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},3954:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return l},default:function(){return p},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return u}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),o=["components"],s={sidebar_position:4},l="Hydra flow",c={unversionedId:"internals/hydra-flow",id:"internals/hydra-flow",title:"Hydra flow",description:"Goal",source:"@site/docs/internals/hydra-flow.md",sourceDirName:"internals",slug:"/internals/hydra-flow",permalink:"/documentation/docs/internals/hydra-flow",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Components",permalink:"/documentation/docs/internals/components"},next:{title:"TODO",permalink:"/documentation/docs/internals/todo"}},d={},u=[{value:"Goal",id:"goal",level:2},{value:"Flow",id:"flow",level:2},{value:"Heartbeat channel",id:"heartbeat-channel",level:3},{value:"Fragments",id:"fragments",level:2},{value:"Fragment render requests via channel",id:"fragment-render-requests-via-channel",level:3}],h={toc:u};function p(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"hydra-flow"},"Hydra flow"),(0,i.kt)("h2",{id:"goal"},"Goal"),(0,i.kt)("p",null,"The goal of Hydra is to provide coupling with Medusa in order to allow for micro-frontends. What we mean by that is the ability to develop and deploy frontends as independent services and then combine them into a singular user experience for the user."),(0,i.kt)("p",null,"Some potential usecases:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Content can be made dynamically available based on the availability of a service. For example, if the ordering system is down, the informational part of the site could still keep working."),(0,i.kt)("li",{parentName:"ul"},"The user only has to log in once, even if different services require different logins."),(0,i.kt)("li",{parentName:"ul"},"New versions of features can be tested by only conditionally exposing it to users via weights (10% of users see new feature, 90% as-is)"),(0,i.kt)("li",{parentName:"ul"},"Etc.")),(0,i.kt)("h2",{id:"flow"},"Flow"),(0,i.kt)("p",null,"The way the flow works is mostly based on Spring Cloud Gateway. We derive the available services at run-time due to RSocket connections. "),(0,i.kt)("p",null,"So in other words, every Medusa app deployed points to a Hydra cluster. This starts a heartbeat RSocket channel."),(0,i.kt)("p",null,"The channel's basic connection / disconnect works as a way to know which services are available to the Hydra cluster. We spread the information to the cluster by simply storing it in memory for singular instances and Redis for clustered deploys."),(0,i.kt)("p",null,"As the channel is active, the two-way connection can be used to pass along fragment data."),(0,i.kt)("h3",{id:"heartbeat-channel"},"Heartbeat channel"),(0,i.kt)("p",null,"Hydra is not the initiator of registry. It simply listens for incoming requests."),(0,i.kt)("p",null,"An app with Medusa will have a pointer to a Hydra instance. (TCP or WS?) It will initiate an RSocket channel with Hydra. It provides its application name, its available paths and its available resources."),(0,i.kt)("p",null,"Any Medusa app only connects to 1 Hydra instance. Hydra shares its information with other Hydra instances via Redis, or keeps it in-memory in case of a single instance.\nWhich Hydra instance it connects to should not matter, to allow for load balancing access."),(0,i.kt)("p",null,"Hydra accepts the channel and uses this incoming information of Medusa's routes/resources. A few things happen:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"It stores the routes/resources in shared memory (thus sharing it with its cluster, if applicable) and changes its overallRouteHashKey in shared memory."),(0,i.kt)("li",{parentName:"ul"},"It creates a FluxSink and stores it in local memory, then returns this. It can use this FluxSink to send back responses to that specific Medusa instance on demand.")),(0,i.kt)("p",null,"Every second, Hydra checks this routeHashKey to see if it has changed. If it has, it will reload all routes/resources from memory and provision Spring Cloud Gateway routes to them.\nSince this data is shared, any Hydra instance in the cluster will pick these up within 1 second, even if they have no direct channel connection."),(0,i.kt)("p",null,"Upon connection termination, Hydra will remove its routes corresponding with the Medusa service and the local memory FluxSink. On the Medusa side, a connection termination will trigger an infinite connection retry every second."),(0,i.kt)("h2",{id:"fragments"},"Fragments"),(0,i.kt)("p",null,"Fragments are the core of combined page micro-frontends. The idea is to have a system that can reliably combine parts of pages from different microservices (aka fragments) into a core page."),(0,i.kt)("p",null,"So the routing works as normal for the core page, but during rendering it will find fragment tags and resolve them by asking Hydra for its info. If no such info is available, it shows the fallback."),(0,i.kt)("p",null,"A core page with a fragment tag would look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Title</title>\n</head>\n<body>\n\n<h1>Hello, this is a core page</h1>\n\n<m:fragment service="orderService" ref="checkout" exports="postalZipCode, addressLine2 as address" imports="dob, countryOrigin as country">\n    Fallback info\n</m:fragment>\n\n</body>\n</html>\n')),(0,i.kt)("p",null,"Fragments must be executed on their respective servers and HTML is returned to the root server where it is 'fragmented'. The servers connect to Hydra anyway, so Hydra can use that connection to ask to render certain HTML."),(0,i.kt)("p",null,"This is illustrated with exports and imports to be as expansive as possible. By default, fragments and their attributes are a fully closed system. In other words, fragments do not interact with the core page or other fragments by default."),(0,i.kt)("p",null,"If such coordination is required, it should be explicitly pointed out."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"An export means that an Attribute with matching keyName will be made available to the core page. In case of a conflict, an exception will be thrown at compile-time. Developers can specify an alias via 'as my-alias' to specify a non-conflicting name."),(0,i.kt)("li",{parentName:"ul"},"An import means that an Attribute available to the core page will be made available to the fragment. These can also be aliased in case of conflict."),(0,i.kt)("li",{parentName:"ul"},"Service / Ref define which Medusa UI app (service) and which page fragment (ref) get used.")),(0,i.kt)("h3",{id:"fragment-render-requests-via-channel"},"Fragment render requests via channel"),(0,i.kt)("p",null,"The heartbeat channel causes a Flux Sink to be generated in local memory, which allows for communication from Hydra to connected services. "),(0,i.kt)("p",null,"Medusa will again initiate the flow, when rendering a root page containing one or more fragments. It sends a List of FragmentRequests to Hydra across the heartbeat channel."),(0,i.kt)("p",null,"Hydra will receive this and map these requests onto active Flux Sinks. Requests without such active Sinks result in null, which means the fallback will be triggered on Medusa side."),(0,i.kt)("p",null,"If an active sink is available, it will be used to forward the relevant FragmentRequests to the relevant Medusa instances. Medusa receives these on its side of the heartbeat channel.\nIt passes the request on to the renderer, which will render it locally and update the Session accordingly. The render and Session then get returned to Hydra."),(0,i.kt)("p",null,"Hydra combines the finished renders and updated Sessions, then sends a ResolvedFragments object back."),(0,i.kt)("p",null,"Medusa can then use this object to complete its rendering."))}p.isMDXComponent=!0}}]);